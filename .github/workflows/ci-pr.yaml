name: "Continuous Integration - Pull Request (AWS EKS)"

# Se activa en Pull Requests hacia la rama main
on:
  pull_request:
    branches:
      - main
    paths-ignore:
      # Ignorar cambios que no afectan el build/deploy
      - '**/README.md'
      - 'kustomize/**'
      - '.github/workflows/kustomize-build-ci.yaml'
      - 'terraform/**'
      - '.github/workflows/terraform-validate-ci.yaml'
      - 'helm-chart/**'
      - '.github/workflows/helm-chart-ci.yaml'

# Evitar que se ejecuten varias instancias al mismo tiempo para el mismo PR
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  # Job de tests de cÃ³digo
  code-tests:
    runs-on: ubuntu-24.04
    steps:
      - uses: actions/checkout@v4  # Obtener cÃ³digo del repositorio
      - uses: actions/setup-dotnet@v4  # Instalar .NET 9
        with:
          dotnet-version: '9.0'
      - uses: actions/setup-go@v5  # Instalar Go 1.24
        with:
          go-version: '1.24'
      - name: Go Unit Tests
        run: |
          # Ejecuta tests para microservicios en Go
          for GO_PACKAGE in "shippingservice" "productcatalogservice" "frontend/validator"; do
            pushd src/$GO_PACKAGE
            go test
            popd
          done
      - name: C# Unit Tests
        run: dotnet test src/cartservice/  # Ejecuta tests de C#

  # Job de deploy temporal para PR
  deployment-tests:
    runs-on: ubuntu-24.04
    needs: code-tests  # Se ejecuta solo si code-tests pasa
    steps:
      - uses: actions/checkout@v4

      # Configurar credenciales de AWS
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v5
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # Login a ECR
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      # Construir y subir la imagen de Docker a ECR
      - name: Build, tag, and push image to Amazon ECR
        run: |
          IMAGE_REPO=${{ steps.login-ecr.outputs.registry }}/online-boutique
          IMAGE_TAG=pr-${{ github.event.pull_request.number }}-${{ github.sha }}
          docker build -t $IMAGE_REPO:$IMAGE_TAG .
          docker push $IMAGE_REPO:$IMAGE_TAG

      # Configurar kubectl para EKS
      - name: Update kubeconfig for EKS
        run: |
          aws eks update-kubeconfig --name online-boutique-cluster --region ${{ secrets.AWS_REGION }}

      # Crear namespace temporal para el PR
      - name: Create Namespace for PR
        run: |
          NAMESPACE=pr${{ github.event.pull_request.number }}
          kubectl create namespace $NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
          echo "NAMESPACE=$NAMESPACE" >> $GITHUB_ENV

      # Desplegar aplicaciÃ³n con Helm
      - name: Deploy application with Helm
        run: |
          helm upgrade --install onlineboutique ./helm-chart \
            --namespace $NAMESPACE --create-namespace \
            --set images.repository=${{ steps.login-ecr.outputs.registry }}/online-boutique \
            --set images.tag=pr-${{ github.event.pull_request.number }}-${{ github.sha }}

      # Esperar que el frontend estÃ© listo
      - name: Wait for pods
        run: |
          kubectl rollout status -n $NAMESPACE deployment/frontend --timeout=300s
          kubectl get pods -n $NAMESPACE

      # Smoke test para validar que frontend responde
      - name: Smoke Test
        run: |
          NAMESPACE=pr${{ github.event.pull_request.number }}
          EXTERNAL_IP=""
          for i in {1..30}; do
            EXTERNAL_IP=$(kubectl get svc frontend-external -n $NAMESPACE -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' || true)
            [ -n "$EXTERNAL_IP" ] && break
            sleep 10
          done
          if [ -z "$EXTERNAL_IP" ]; then
            echo "ERROR: No external IP found for frontend"
            exit 1
          fi
          curl -s --retry 5 --retry-delay 10 http://$EXTERNAL_IP > /dev/null

      # Comentar en el PR la URL del deployment
      - name: Comment EXTERNAL_IP
        env:
          COMMENTS_URL: ${{ github.event.pull_request.comments_url }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          NAMESPACE=pr${{ github.event.pull_request.number }}
          EXTERNAL_IP=$(kubectl get svc frontend-external -n $NAMESPACE -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          curl -X POST $COMMENTS_URL \
            -H "Content-Type: application/json" \
            -H "Authorization: token $GITHUB_TOKEN" \
            --data "{ \"body\": \"ðŸš€ PR desplegado en: http://$EXTERNAL_IP\" }"
