name: "Continuous Integration - Pull Request (AWS EKS)"

on:
  pull_request:
    branches:
      - main
    paths-ignore:
      - '**/README.md'
      - 'kustomize/**'
      - '.github/workflows/kustomize-build-ci.yaml'
      - 'terraform/**'
      - '.github/workflows/terraform-validate-ci.yaml'
      - 'helm-chart/**'
      - '.github/workflows/helm-chart-ci.yaml'

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  code-tests:
    runs-on: ubuntu-24.04
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-dotnet@v4
        env:
          DOTNET_INSTALL_DIR: "./.dotnet"
        with:
          dotnet-version: '9.0'
      - uses: actions/setup-go@v5
        with:
          go-version: '1.24'
      - name: Go Unit Tests
        timeout-minutes: 10
        run: |
          for GO_PACKAGE in "shippingservice" "productcatalogservice" "frontend/validator"; do
            echo "Testing $GO_PACKAGE..."
            pushd src/$GO_PACKAGE
            go test
            popd
          done
      - name: C# Unit Tests
        timeout-minutes: 10
        run: |
          dotnet test src/cartservice/

  deployment-tests:
    runs-on: ubuntu-24.04
    needs: code-tests
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}

      # Configurar credenciales de AWS
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # Login en Amazon ECR
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      # Build y push de la imagen del PR
      - name: Build, tag, and push image to Amazon ECR
        run: |
          IMAGE_REPO=${{ steps.login-ecr.outputs.registry }}/online-boutique
          IMAGE_TAG=pr-${{ github.event.pull_request.number }}-${{ github.sha }}
          echo "Building image: $IMAGE_REPO:$IMAGE_TAG"

          docker build -t $IMAGE_REPO:$IMAGE_TAG .
          docker push $IMAGE_REPO:$IMAGE_TAG

      # Configurar kubectl para EKS
      - name: Update kubeconfig for EKS
        run: |
          aws eks update-kubeconfig --name online-boutique-cluster --region ${{ secrets.AWS_REGION }}

      # Crear namespace temporal para el PR
      - name: Create Namespace for PR
        run: |
          NAMESPACE=pr${{ github.event.pull_request.number }}
          kubectl create namespace $NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
          echo "NAMESPACE=$NAMESPACE" >> $GITHUB_ENV

      # Desplegar la app al namespace
      - name: Deploy application to EKS
        run: |
          kubectl apply -n $NAMESPACE -f k8s-manifests/

      # Esperar a que todos los pods estÃ©n listos
      - name: Wait for pods
        run: |
          kubectl rollout status -n $NAMESPACE deployment/frontend --timeout=300s
          kubectl get pods -n $NAMESPACE

      # Smoke test (verificar que el frontend responde)
      - name: Smoke Test
        run: |
          NAMESPACE=pr${{ github.event.pull_request.number }}
          EXTERNAL_IP=""
          for i in {1..30}; do
            EXTERNAL_IP=$(kubectl get svc frontend-external -n $NAMESPACE -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' || true)
            if [ -n "$EXTERNAL_IP" ]; then break; fi
            echo "Waiting for LoadBalancer IP..."
            sleep 10
          done
          if [ -z "$EXTERNAL_IP" ]; then
            echo "ERROR: No external IP found for frontend"
            exit 1
          fi
          echo "Frontend available at http://$EXTERNAL_IP"
          curl -s --retry 5 --retry-delay 10 http://$EXTERNAL_IP > /dev/null

      # Comentar en el PR la URL del deployment
      - name: Comment EXTERNAL_IP
        env:
          COMMENTS_URL: ${{ github.event.pull_request.comments_url }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          NAMESPACE=pr${{ github.event.pull_request.number }}
          EXTERNAL_IP=$(kubectl get svc frontend-external -n $NAMESPACE -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          curl \
            -X POST \
            $COMMENTS_URL \
            -H "Content-Type: application/json" \
            -H "Authorization: token $GITHUB_TOKEN" \
            --data "{ \"body\": \"ðŸš€ PR desplegado en: http://$EXTERNAL_IP\" }"
