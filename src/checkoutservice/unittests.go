// Copyright 2018 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"context"
	"fmt"
	"testing"

	"github.com/google/uuid"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	pb "github.com/GoogleCloudPlatform/microservices-demo/src/checkoutservice/genproto"
	money "github.com/GoogleCloudPlatform/microservices-demo/src/checkoutservice/money"
)

func TestCheckout(t *testing.T) {
	t.Run("empty cart returns INVALID_ARGUMENT", func(t *testing.T) {
		_, err := cs.PlaceOrder(context.Background(), &pb.PlaceOrderRequest{UserId: "test_user", UserCurrency: usdCurrency})
		if err == nil {
			t.Error("got OK, want INVALID_ARGUMENT")
		}
		if code := status.Code(err); code != codes.InvalidArgument {
			t.Errorf("got code %q, want %q", code, codes.InvalidArgument)
		}
	})

	t.Run("missing user returns INVALID_ARGUMENT", func(t *testing.T) {
		_, err := cs.PlaceOrder(context.Background(), &pb.PlaceOrderRequest{UserCurrency: usdCurrency})
		if err == nil {
			t.Error("got OK, want INVALID_ARGUMENT")
		}
		if code := status.Code(err); code != codes.InvalidArgument {
			t.Errorf("got code %q, want %q", code, codes.InvalidArgument)
		}
	})

	t.Run("missing currency returns INVALID_ARGUMENT", func(t *testing.T) {
		_, err := cs.PlaceOrder(context.Background(), &pb.PlaceOrderRequest{UserId: "test_user"})
		if err == nil {
			t.Error("got OK, want INVALID_ARGUMENT")
		}
		if code := status.Code(err); code != codes.InvalidArgument {
			t.Errorf("got code %q, want %q", code, codes.InvalidArgument)
		}
	})

	t.Run("pre-existing cart is charged correctly", func(t *testing.T) {
		// ID generated by first request, which adds item to cart.
		orderID := "test-order-1"

		_, err := cs.PlaceOrder(context.Background(), &pb.PlaceOrderRequest{
			UserId:       "test_user",
			UserCurrency: usdCurrency,
			Address: &pb.Address{
				StreetAddress: "123 Main St",
				City:          "San Francisco",
				State:         "CA",
				Country:       "USA",
				ZipCode:       "94111",
			},
			Email: "test@example.com",
			CreditCard: &pb.CreditCardInfo{
				CreditCardNumber: "1234567890123456",
				CreditCardCvv:    "123",
				CreditCardExpirationYear:  2025,
				CreditCardExpirationMonth: 12,
			},
		})
		if err != nil {
			t.Fatalf("PlaceOrder failed: %+v", err)
		}

		resp, err := orderSvc.GetOrder(context.Background(), &pb.GetOrderRequest{OrderId: orderID})
		if err != nil {
			t.Fatalf("GetOrders failed: %+v", err)
		}
		order := resp.GetOrder()
		if order == nil {
			t.Fatal("GetOrders returned a nil order")
		}

		wantCost := func(currency string, units, nanos int64) *pb.Money {
			return &pb.Money{CurrencyCode: currency, Units: units, Nanos: nanos}
		}

		// Verify that the order contains the expected values.
		if got, want := order.GetShippingCost(), wantCost(usdCurrency, 10, 0); !money.Equal(got, want) {
			t.Errorf("got shipping cost: %+v, want %+v", got, want)
		}
		if got, want := len(order.GetItems()), 1; got != want {
			t.Errorf("got %q items in order, want %q", got, want)
		}
		orderItem := order.GetItems()[0]
		if got, want := orderItem.GetCost(), wantCost(usdCurrency, 20, 0); !money.Equal(got, want) {
			t.Errorf("got order item cost: %+v, want %+v", got, want)
		}
		if got, want := orderItem.GetItem().GetProductId(), "OLJCESPC7Z"; got != want {
			t.Errorf("got order item product ID: %q, want %q", got, want)
		}
		if got, want := orderItem.GetItem().GetQuantity(), 1; got != want {
			t.Errorf("got order item quantity: %q, want %q", got, want)
		}
	})
}

func TestGetShippingQuote(t *testing.T) {
	tests := []struct {
		name    string
		address *pb.Address
		items   []*pb.CartItem
		want    *pb.Money
		wantErr bool
	}{
		{
			"empty request",
			nil,
			nil,
			nil,
			true,
		},
		{
			"empty cart",
			&pb.Address{
				StreetAddress: "123 Main St",
				City:          "San Francisco",
				State:         "CA",
				Country:       "USA",
				ZipCode:       "94111",
			},
			nil,
			nil,
			true,
		},
		{
			"valid request",
			&pb.Address{
				StreetAddress: "123 Main St",
				City:          "San Francisco",
				State:         "CA",
				Country:       "USA",
				ZipCode:       "94111",
			},
			[]*pb.CartItem{
				{
					ProductId: "OLJCESPC7Z",
					Quantity:  1,
				},
			},
			&pb.Money{
				CurrencyCode: "USD",
				Units:        10,
				Nanos:        0,
			},
			false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := cs.quoteShipping(context.Background(), tt.address, tt.items)
			if (err != nil) != tt.wantErr {
				t.Errorf("checkoutService.quoteShipping() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !money.Equal(got, tt.want) {
				t.Errorf("checkoutService.quoteShipping() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestGetProduct(t *testing.T) {
	tests := []struct {
		name    string
		id      string
		want    *pb.Product
		wantErr bool
	}{
		{
			"invalid id",
			"-1",
			nil,
			true,
		},
		{
			"valid id",
			"OLJCESPC7Z",
			&pb.Product{
				Id:          "OLJCESPC7Z",
				Name:        "Red hat",
				Description: "A red hat",
				PriceUsd: &pb.Money{
					CurrencyCode: "USD",
					Units:        20,
					Nanos:        0,
				},
			},
			false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := productCatalogSvc.GetProduct(context.Background(), &pb.GetProductRequest{Id: tt.id})
			if (err != nil) != tt.wantErr {
				t.Errorf("productCatalogSvc.GetProduct() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if got != nil && tt.want != nil {
				if got.GetId() != tt.want.GetId() ||
					got.GetName() != tt.want.GetName() ||
					got.GetDescription() != tt.want.GetDescription() ||
					!money.Equal(got.GetPriceUsd(), tt.want.GetPriceUsd()) {
					t.Errorf("productCatalogSvc.GetProduct() = %v, want %v", got, tt.want)
				}
			}
		})
	}
}

func TestConvertCurrency(t *testing.T) {
	tests := []struct {
		name    string
		from    *pb.Money
		toCode  string
		want    *pb.Money
		wantErr bool
	}{
		{
			"empty request",
			nil,
			"",
			nil,
			true,
		},
		{
			"invalid from",
			&pb.Money{
				CurrencyCode: "invalid",
				Units:        10,
				Nanos:        0,
			},
			"USD",
			nil,
			true,
		},
		{
			"valid request",
			&pb.Money{
				CurrencyCode: "USD",
				Units:        10,
				Nanos:        0,
			},
			"USD",
			&pb.Money{
				CurrencyCode: "USD",
				Units:        10,
				Nanos:        0,
			},
			false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := cs.convertCurrency(context.Background(), tt.from, tt.toCode)
			if (err != nil) != tt.wantErr {
				t.Errorf("checkoutService.convertCurrency() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !money.Equal(got, tt.want) {
				t.Errorf("checkoutService.convertCurrency() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestChargeCard(t *testing.T) {
	tests := []struct {
		name       string
		amount     *pb.Money
		paymentInfo *pb.CreditCardInfo
		want       string
		wantErr    bool
	}{
		{
			"empty request",
			nil,
			nil,
			"",
			true,
		},
		{
			"invalid card",
			&pb.Money{
				CurrencyCode: "USD",
				Units:        10,
				Nanos:        0,
			},
			&pb.CreditCardInfo{
				CreditCardNumber: "invalid",
				CreditCardCvv:    "invalid",
				CreditCardExpirationYear:  2020,
				CreditCardExpirationMonth: 1,
			},
			"",
			true,
		},
		{
			"valid request",
			&pb.Money{
				CurrencyCode: "USD",
				Units:        10,
				Nanos:        0,
			},
			&pb.CreditCardInfo{
				CreditCardNumber: "1234567890123456",
				CreditCardCvv:    "123",
				CreditCardExpirationYear:  2025,
				CreditCardExpirationMonth: 12,
			},
			"payment-1234567890",
			false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := cs.chargeCard(context.Background(), tt.amount, tt.paymentInfo)
			if (err != nil) != tt.wantErr {
				t.Errorf("checkoutService.chargeCard() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if got != tt.want {
				t.Errorf("checkoutService.chargeCard() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestPlaceOrder(t *testing.T) {
	tests := []struct {
		name    string
		req     *pb.PlaceOrderRequest
		wantErr bool
	}{
		{
			"missing user id",
			&pb.PlaceOrderRequest{
				UserCurrency: "USD",
				Address: &pb.Address{
					StreetAddress: "123 Main St",
					City:          "San Francisco",
					State:         "CA",
					Country:       "USA",
					ZipCode:       "94111",
				},
				Email: "test@example.com",
				CreditCard: &pb.CreditCardInfo{
					CreditCardNumber: "1234567890123456",
					CreditCardCvv:    "123",
					CreditCardExpirationYear:  2025,
					CreditCardExpirationMonth: 12,
				},
			},
			true,
		},
		{
			"missing user currency",
			&pb.PlaceOrderRequest{
				UserId: "test_user",
				Address: &pb.Address{
					StreetAddress: "123 Main St",
					City:          "San Francisco",
					State:         "CA",
					Country:       "USA",
					ZipCode:       "94111",
				},
				Email: "test@example.com",
				CreditCard: &pb.CreditCardInfo{
					CreditCardNumber: "1234567890123456",
					CreditCardCvv:    "123",
					CreditCardExpirationYear:  2025,
					CreditCardExpirationMonth: 12,
				},
			},
			true,
		},
		{
			"valid request",
			&pb.PlaceOrderRequest{
				UserId:       "test_user",
				UserCurrency: "USD",
				Address: &pb.Address{
					StreetAddress: "123 Main St",
					City:          "San Francisco",
					State:         "CA",
					Country:       "USA",
					ZipCode:       "94111",
				},
				Email: "test@example.com",
				CreditCard: &pb.CreditCardInfo{
					CreditCardNumber: "1234567890123456",
					CreditCardCvv:    "123",
					CreditCardExpirationYear:  2025,
					CreditCardExpirationMonth: 12,
				},
			},
			false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			_, err := cs.PlaceOrder(context.Background(), tt.req)
			if (err != nil) != tt.wantErr {
				t.Errorf("checkoutService.PlaceOrder() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
		})
	}
}

func TestPrepareOrderItemsAndShippingQuoteFromCart(t *testing.T) {
	tests := []struct {
		name      string
		userID    string
		userCurrency string
		address   *pb.Address
		want      orderPrep
		wantErr   bool
	}{
		{
			"empty request",
			"",
			"",
			nil,
			orderPrep{},
			true,
		},
		{
			"valid request",
			"test_user",
			"USD",
			&pb.Address{
				StreetAddress: "123 Main St",
				City:          "San Francisco",
				State:         "CA",
				Country:       "USA",
				ZipCode:       "94111",
			},
			orderPrep{
				orderItems: []*pb.OrderItem{
					{
						Item: &pb.CartItem{
							ProductId: "OLJCESPC7Z",
							Quantity:  1,
						},
						Cost: &pb.Money{
							CurrencyCode: "USD",
							Units:        20,
							Nanos:        0,
						},
					},
				},
				cartItems: []*pb.CartItem{
					{
						ProductId: "OLJCESPC7Z",
						Quantity:  1,
					},
				},
				shippingCostLocalized: &pb.Money{
					CurrencyCode: "USD",
					Units:        10,
					Nanos:        0,
				},
			},
			false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name
